%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Анализ подходов к генерации спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе рассматриваются существующие подходы к автоматизированной генерации спецификаций.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Подходы к генерации спецификациии}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже перечислены основные подходы к генерации формальной спецификации библиотек:
%
\begin{itemize*}
\item Извлечение автоматов и списка функций(структура библиотеки)
\item Извлечение контрактов(предусловий и постусловий) для каждой функции
\item Извлечение окружения состояния автоматов и переходов автоматов
\end{itemize*}
%

Чаще всего существующие подходы можно отнести к статическому типу. Но также можно встретить и динамические подходы ивзлечения контрактов функции, но это, как следует из практики, негативно сказывается на производительности.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Извлечение автоматов и списка функций}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Данный подход является основополагающим в генерации спецификации. Суть довольно проста, сгенерировать такой каркас спецификации, который бы соответствовал структуре библиотеки (имена классов, сигнатуры функций и т.д.).

Одним из способов генерировать спецификации является генератор спецификаций AutoJML\cite{autoJML_paper}\cite{autoJML}.
Он генерирует спецификации на основе формализмов других более высоких уровней, таких как диаграммы состояний UML или спецификации протоколов безопасности. Результатом является комбинация каркасного кода Java и спецификаций классов и методов JML.

Для данной работы был выбран язык спецификации компонентов программного обеспечения LibSL\cite{libsl}\cite{libsl2}. По причине разницы в языках спецификации предложенный инструмент не является подходящим для целей работы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Извлечение предусловий и постусловий для функции}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Один из вариантов, с помощью которого можно дополнить сгенерированный каркас спецификации, то есть структуру библиотеки, это детектор инвариантов. Такие детекторы помогают но основе исходного кода библиотеки генерировать постусловия и предусловия для каждой отдельной функции в классах библиотеки.

Один из примеров реализации данного подхода является система Daikon\cite{daikon}\cite{daikon_paper}, позволяющая сообщать о вероятных инвариантов программы. Daikon запускает программу и наблюдает за значениями, которые вычисляются программой, и после чего сообщает о свойствах, которые были истинными для наблюдаемых функций.
Daikon может обнаруживать инварианты в программах на C, C++, Java, Perl и других. Можно выбрать анализ только для конкретной части программы, чтобы избежать перегруженности вывода.

В случае работы с файлами Java обнаружение состоит из двух частей:
%
\begin{itemize*}
\item Создание файлов трассировки данных
\item Запуск детектора инвариантов над файлами трассировки даных
\end{itemize*}
%
Просматривать инварианты после их генерации можно в текстовом виде или же с помощью дополнительных инструментов.

Недостатком данной утилиты является динамическое обнаружение, что сильно сказывается на производительности не в лучшую сторону.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Извлечение окружения состояния автоматов и переходов автоматов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Решение данного подхода само по себе является довольно трудоемкой задачей. Идея подхода состоит в том, чтобы автоматически генерировать  состояния и переходы автоматов для LibSL спецификации, путем анализа сайтов вопросов и ответов (например, StackOverflow) или исходного кода программ, использующих библиотеку (например, репозитории на GitHub), для которой генерируется спецификация.

Одно из решений, которое бы помогло в решении данного подхода является автоматический генератор комментариев для исходного кода AutoComment.
Данный инструмент применяет методы обработки естественного языка (NLP) и эвристики проектирования, что позволяет улучшить описания кода для создания комментариев.
Утилита состоит из двух основных компонентов:
%
\begin{itemize*}
\item Компонент для создания базы данных отображений описания кода
\item Компонент для генерации комментариев для целевого программного обеспечения
\end{itemize*}
%

Недостатком предложенного инструмента является то, что для решения подхода необходимо использовать его в неявном виде, то есть кроме самого инструмента понадобится дополнительная утилита для  извлечения окружения состояния автоматов.

\nomenclature{NLP}{Natural language processing}

Мы применяем методы обработки естественного языка (NLP) и эвристики проектирования, чтобы улучшить описания кода для создания высококачественных комментариев.