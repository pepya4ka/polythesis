%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование инструмента автоматизированной генерации спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этом разделе разработанный инструмент автоматизированной генерации спецификации проходит на проверку на то, чтобы все требования, которые были поставлены в начале работы, были соблюдены.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программа тестирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для того, чтобы проверить, что наш инструмент корректно извлекает спецификацию нам необходимо проверить, что, например, классы корректно превращаются в автоматы.
Ниже в таблице \ref{tabular:second_tab} представлены элементы библиотеки и соответствующие им элементы спецификации:
\begin{table}[H]
	\caption{Элементы библиотеки и соответствующие им элементы спецификации}
	\begin{center}
		\begin{tabular}{|p{5.5cm}|p{5.5cm}|}
			\hline
			Элемент библиотеки & Элемент спецификации\\ \hline

			Все импортируемые файла и пакеты & Описание о подключаемых файлов и пакетов\\ \hline
			Все типы, которые есть в библиотеке & Описание псевдонимов типов\\ \hline
			Публичные методы классов & Публичные функции API\\ \hline
			Класс библиотеки & Автомат спецификации\\ \hline
		\end{tabular}
		\label{tabular:second_tab}
	\end{center}
\end{table}

И также необходимо проверить, что извлекаются аннотации влияния функции на окружения.

Перечисленные пункты необходимо проверить, так как они являются основной для каркаса спецификации.
Это позволит нам дать оценку корректности работы нашего инструмента.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Методика тестирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для проверки корректности работы нашего инструменты мы проведем несколько экспериментов с несколькими библиотеками.

Для того, чтобы проверить, что извлекаются все импортируемые файлы и пакеты, вручную посчитаем количество импортируемых файлов и посмотрим, что все они появились в файле LibSL после извлечения.
После чего, в качестве дополнительной проверки, вручную добавим какой-либо импортируемый пакет и также проанализируем результат.
Для типов, классов и публичных методов библиотеки проведем аналогичные эксперименты с соответствующими элементами.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Результаты тестирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Главной задачей в данном разделе было показать результаты экспериментов, описанных в разделах выше.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Описание о подключаемых файлов и пакетов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Имея простой класс (см.~\ref{listings:TestPerson}) мы можем получить следующий LibSL файл, представленный в листинге~\ref{listings:test_1_1}.
\lstinputlisting[
label={listings:test_1_1},
caption={Пример сгенерированного LibSL},
style=java,
]
{src/lslcode/test_1_1.txt}

Добавим несколько импортируемых пакетов в исходный код и снова простестируем. Сгенерированный LibSL представлен в листинге~\ref{listings:test_1_2}.
\lstinputlisting[
label={listings:test_1_2},
caption={Пример сгенерированного LibSL с добавленными импортами},
style=java,
]
{src/lslcode/test_1_2.txt}

Проведем тестирование на другой библиотеке. Сгенерированный LibSL представлен в листинге~\ref{listings:test_1_3}.
\lstinputlisting[
label={listings:test_1_3},
caption={Пример сгенерированного LibSL},
style=java,
]
{src/lslcode/test_1_3.txt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Описание псевдонимов типов и публичные функции API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Имея результат представленный в листинге~\ref{listings:test_1_1}.
Изменим исходный класс, добавив в него новый публичный метод с неиспользуемым ранее в классе возвращаемым типом.
Например, добавим геттер и сеттер для поля класса date;
Результат генерации представлен в листинге~\ref{listings:test_1_4}.
\lstinputlisting[
label={listings:test_1_4},
caption={Пример сгенерированного LibSL с добавленными методами},
style=java,
]
{src/lslcode/test_1_4.txt}

Как видно из результата, новые публичные методы и описание нового типа успешно были извлечены.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Извлечение аннотаций влияния на окружения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Методика проверка того что, правильно извлекается аннотация влияния окружения. Например, к нашему исходному классу (см.~\ref{listings:TestPerson}) добавим еще один простой класс (см.~\ref{listings:TestExperience}), состоящий из одного публичного поля и конструктора.
После чего добавим к классу Person метод, который представлен в листинге~\ref{listings:NewMethod}.
\lstinputlisting[
label={listings:NewMethod},
caption={Пример сгенерированного LibSL с добавленными методами},
style=java,
]
{src/testClasses/NewMethod.java}

Запустим наш инструмент и проверяем, что в спецификации появился признак, что поля аргумента experience ассайнится в добавленном нами методе.
Результат генерации представлен в листинге~\ref{listings:test_1_5}.
\lstinputlisting[
label={listings:test_1_5},
caption={Пример сгенерированного LibSL с извлеченной аннотацией},
style=java,
]
{src/lslcode/test_1_5.txt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Тестирование на простой библиотеке}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В качестве простой библиотеки подразумевается небольшая самописная состоящая из нескольких простых классов и одного интерфейса

Результат работы инструмента с этой библиотекой является lsl файл, фрагмент которого приведен в листинге ~\ref{listings:my_lsl}:
\lstinputlisting[
label={listings:my_lsl},
caption={Пример сгенерированного LibSL},
style=java,
]
{src/lslcode/my_lsl.txt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Тестирование на библиотеке okhttp3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для еще одного этапа тестирования была выбрана библиотека okhttp3 \cite{okhttp}.

Результат работы инструмента с этой библиотекой является lsl файл, фрагмент которого приведен ниже в листинге ~\ref{listings:okhttp_lsl}:
\lstinputlisting[
label={listings:okhttp_lsl},
caption={Пример сгенерированного LibSL для библиотеки okhttp},
style=java,
]
{src/lslcode/http_lsl.txt}

Для экономии места часть кода была удалена.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Тестирование результатов с помощью парсера}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Единственным автоматизированным способом проверки разработанного инструмента является существующий парсер LibSL спецификации \cite{libsl_parser}.

Ниже в листинге ~\ref{listings:javaparser} представлен фрагмент кода, показывающий взаимодействие с данной библиотекой:
\lstinputlisting[
label={listings:javaparser},
caption={Валидация сгенерированного LibSL файла с помощью парсера},
style=java,
]
{src/fragments/LibSLParserExample.java}

На вход парсеру падается сгенерированный файл спецификации с расширением lsl. Парсер в свою очередь преобразует спецификацию в абстрактный семантический граф.
Если результатом является какое-либо исключение, нетрудно догадаться, что в спецификации есть ошибки, на которые парсер также явно указывает в выводе.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Вывод}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе была рассмотрена программа тестирования с помощью предложенного парсера LibSL спецификаций, а также данный раздел включает в себя фрагменты сгенерированных спецификаций на различных библиотеках.
Тестирование показало, что инструмент выполняет поставленные перед ним задачи генерации спецификации.

