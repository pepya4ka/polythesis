%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка инструмента автоматизированной генерации спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этом разделе рассматривается реализация прототипа инструмента автоматизированной генерации спецификации в соответствии с требованиями, предложенными методами генерации структуры спецификации, а также метода извлечения аннотаций, описывающие влияние функции на окружающую среду.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Средства разработки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Инструмент был написан на языке Java. Преимущество использование языка Java является то, что язык транслируется виртуальной машиной Java, поэтому имеется возможность использовать различные библиотеки написанные как на Java, так и, например, на Kotlin.
К тому же исходным языком для библиотек также был выбран язык Java, что является одной из причин выбор данного языка.

Для того, чтобы читать и анализировать Java и jar файлы необходимо было выбрать соответствующие библиотеки.
Для чтения jar-файлов используется стандартные классы из библиотек Java (например, InputStream, JarInputStream или JarEntry).
Непосредственно для анализа каждой записи в jar-файле используется библиотека Apache Commons BCEL \cite{bcel}. Выбранная библиотека предоставляет довольно удобный способ анализа class-файлов Java (*.class).
В библиотеке классы представлены как объекты, которые содержат всю необходимую для анализа информацию данного класса:
%
\begin{itemize*}
\item Методы;
\item Поля класса;
\item Инструкции байт-кода;
\end{itemize*}
%

Для чтения java файлов используется библиотека Javaparser \cite{javaparser}. Данная библиотека позволяет читать java файлы и быстро генерировать на их основе абстрактное синтаксическое дерево. Затем благодаря структуре AST библиотека позволяет простым программным способом анализировать код.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выбор модели анализа}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Как было сказано в предыдущих главах, статический анализ имеет различные модели, такие как CFG и AST.
Окончательно выбор пал на модель AST, так как в нем отсутствует информация о форматировании кода, а также промежуточных узлах и таких синтаксических элементах, как скобки, точки с запятыми и т.д.
Собственно это и является одной из причин выбора библиотеки для анализа JavaParser.

Стоит отметить, что модель CFG также подходит для данной работы, так как CFG имеет возможность для анализа возможных путей исполнения программы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация предложенного метода извлечения структуры спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были описаны некоторые детали реализации предложенного метода извлечения структуры спецификации.

Для удобства работы с извлеченной информацией были созданы три основных модели объектов в языке LibSL:
%
\begin{itemize*}
\item TypeAlias;
\item Automaton;
\item Fun;
\end{itemize*}
%

Данные модели представлены в виде POJO (Plain Old Java Object). Каждый из классов имеют свою индивидуальную структуру. Например,
\nomenclature{CFG}{Control Flow Graph}
В ходе своей работы инструменты необходимо обрабатывать директории с исходным кодом библиотеки, либо же jar-файл библиотеки.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью BCEL}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже представлен фрагмент кода, который инициализирует основной класс для анализа фрагментов jar-файла, с помощью которого в дальнейшем происходит вся работа по извлечению структуры:
\lstinputlisting[
label={listings:javaparser},
caption={Инициализация анализатора BCEL},
style=java,
]
{src/fragments/BCELAnalyzerInit.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью JavaParser}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже представлен фрагмент кода, который инициализирует и настраивает анализатор JavaParser для работы с файлами
\lstinputlisting[
label={listings:javaparser},
caption={Инициализация и настройка анализатора JavaParser},
style=java,
]
{src/fragments/InitJavaParserAnalyzer.java}

Имея инициализированный и настроенный анализатор, а также список файлов исходного кода, которая подается на вход программы, система приступает к анализу этих файлов.

Анализ происходит с помощью встроенных в библиотеку методов, с помощью которых извлекается вся необходимая информация для построения спецификации.

Например, ниже приведен код, с помощью которого извлекается информация для наполнения спецификации информацией о подключаемых файлов и пакетов:
\lstinputlisting[
label={listings:javaparser},
caption={Извлечение информации о подключаемых файлов и пакетов},
style=java,
]
{src/fragments/ExtractionLibraryInfoWithJavaParser.java}

Аналогичным образом извлекается вся структура библиотеки.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация предложенного метода извлечения аннотаций}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были описаны некоторые детали реализации предложенного метода извлечения структуры спецификации.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью JavaParser}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Библиотека предлагает встроенные методы для работы с AST, поэтому был написан метод извлечения информации влияния функции на окружение.
Библиотека предлагает работать с существующими классами Expression, которые и содержат необходимые данные, а именно всю информацию об дочерних и родительских узлах. Имея набор аргумент необходимо было понять какие выражения соответствуют выражениям присваивания для аргументов функции.
Для этого библиотека также предусматривает все необходимое.

Также стоит отметить, что реализация написанная с помощью библиотеки BCEL полностью готова к расширению.

Последней частью реализации, как уже было сказано ранее, была задача создания метода непосредственной генерации кода на языке LibSL.
На данный момент код записывается в выходной файл с расширением .lsl.

Например, ниже приведен фрагмент кода, с помощью которого в файл записывается информация о описании псевдонимов типов:
\lstinputlisting[
label={listings:javaparser},
caption={Вывод информации о описании псевдонимов типов в файл},
style=java,
]
{src/fragments/OutputTypeAliasInFile.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были рассмотрены детали реализации прототипа инструмента автоматизированной генерации формальной спецификации библиотеки на языке LibSL.