%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка инструмента автоматизированной генерации спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этом разделе рассматривается реализация прототипа инструмента автоматизированной генерации спецификации в соответствии с требованиями, предложенными методами генерации структуры спецификации, а также метода извлечения аннотаций, описывающие влияние функции на окружающую среду.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Средства разработки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Инструмент был написан на языке Java. Преимущество использование языка Java является то, что язык транслируется виртуальной машиной Java, поэтому имеется возможность использовать различные библиотеки написанные как на Java, так и, например, на Kotlin.
К тому же исходным языком для библиотек также был выбран язык Java, что является одной из причин выбор данного языка.

Для того, чтобы читать и анализировать Java и jar файлы необходимо было выбрать соответствующие библиотеки.
Для чтения jar-файлов используется стандартные классы из библиотек Java (например, InputStream, JarInputStream или JarEntry).
Непосредственно для анализа каждой записи в jar-файле используется библиотека Apache Commons BCEL \cite{bcel}. Выбранная библиотека предоставляет довольно удобный способ анализа class-файлов Java (*.class).
В библиотеке классы представлены как объекты, которые содержат всю необходимую для анализа информацию данного класса:
%
\begin{itemize*}
\item Методы;
\item Поля класса;
\item Инструкции байт-кода;
\end{itemize*}
%

Для чтения java файлов используется библиотека Javaparser \cite{javaparser}. Данная библиотека позволяет читать java файлы и быстро генерировать на их основе абстрактное синтаксическое дерево. Затем благодаря структуре AST библиотека позволяет простым программным способом анализировать код.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выбор модели анализа}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Как было сказано в предыдущих главах, статический анализ имеет различные модели, такие как CFG и AST.
Для полноценного анализа влияния на окружение необходимо анализировать динамику исполнения программы.
Для этого нужны такие модели как CFG или SSA (Single Static Assignment).

Однако в данной работе, в связи нехваткой времени, для упрощения, мы выбрали более простой путь, но который дает более грубый результат - это анализ абстрактного синтаксического дерева.

\nomenclature{SSA}{Static single-assignment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация предложенного метода извлечения структуры спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были описаны некоторые детали реализации предложенного метода извлечения структуры спецификации.

Для удобства работы с извлеченной информацией были созданы три основных модели объектов в языке LibSL:
%
\begin{itemize*}
\item TypeAlias (~\ref{listings:TypeAlias});
\item Automaton (~\ref{listings:Automaton});
\item Fun (~\ref{listings:Fun});
\end{itemize*}
%

Данные модели представлены в виде POJO (Plain Old Java Object). Каждый из классов имеют свою индивидуальную структуру. Например,
\nomenclature{POJO}{Plain Old Java Object}
В ходе своей работы инструменту необходимо обрабатывать директории с исходным кодом библиотеки, либо же jar-файл библиотеки.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью BCEL}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже, в листинге~\ref{listings:bcel}, представлен фрагмент кода, который инициализирует основной класс для анализа фрагментов jar-файла, с помощью которого в дальнейшем происходит вся работа по извлечению структуры:
\lstinputlisting[
label={listings:bcel},
caption={Инициализация анализатора BCEL},
style=java,
]
{src/fragments/BCELAnalyzerInit.java}

Также стоит отметить, что реализация написанная с помощью библиотеки BCEL полностью готова к расширению.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью JavaParser}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже, в листинге~\ref{listings:javaparser}, представлен фрагмент кода, который инициализирует и настраивает анализатор JavaParser для работы с файлами
\lstinputlisting[
label={listings:javaparser},
caption={Инициализация и настройка анализатора JavaParser},
style=java,
]
{src/fragments/InitJavaParserAnalyzer.java}

Имея инициализированный и настроенный анализатор, а также список файлов исходного кода, которая подается на вход программы, система приступает к анализу этих файлов.
Анализ происходит с помощью встроенных в библиотеку методов, с помощью которых извлекается вся необходимая информация для построения спецификации.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Заголовок библиотеки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Описание о подключаемых файлах или пакетов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже, в листинге~\ref{listings:LibraryInfo}, приведен фрагмент кода, с помощью которого извлекается информация для наполнения спецификации информацией о подключаемых файлов и пакетов:
\lstinputlisting[
label={listings:LibraryInfo},
caption={Извлечение информации о подключаемых файлов и пакетов},
style=java,
]
{src/fragments/ExtractionLibraryInfoWithJavaParser.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Описание псевдонимов типов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для каждого класса, который в исходной библиотеке, создается его описание. Для этого была создана модель TypeAlias (см.(~\ref{listings:TypeAlias})).
Аналогичная ситуация обстоит и с классами, которые не входят в состав библиотеки, но используется, например, в качестве типа выходного параметра функции или ее аргументов.

Ниже, в листинге~\ref{listings:NewTypeAlias}, приведен метод, с помощью которого создается и сохраняется описание типа. На вход метод принимает имя класса.
\lstinputlisting[
label={listings:NewTypeAlias},
caption={Создание объекта TypeAlias},
style=java,
]
{src/fragments/NewTypeAliasExample.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Описание автоматов и функций API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ниже, в листинге~\ref{listings:NewFunExample}, приведен фрагмент кода, в котором в распарсенном классе перебираются все публичные методы класса и создается объект, созданной ранее модели Fun, поля которого и будут заполняться.
Например, устанавливается возвращаемоез значение, полученное из парсинга метода класса.
\lstinputlisting[
label={listings:NewFunExample},
caption={Создание объекта Fun},
style=java,
]
{src/fragments/NewFunExample.java}

Ниже, в листинге~\ref{listings:NewAutomatonExample}, приведен фрагмент кода, с помощью которого извлекается имя класса и создается новый объект Automaton, а также объект наполняется ранее созданным объектом Fun:
\lstinputlisting[
label={listings:NewAutomatonExample},
caption={Создание объекта Automaton},
style=java,
]
{src/fragments/NewAutomatonExample.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация предложенного метода извлечения аннотаций}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были описаны некоторые детали реализации предложенного метода извлечения структуры спецификации.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Реализация с помощью JavaParser}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Библиотека предлагает встроенные методы для работы с AST, поэтому был написан метод извлечения информации влияния функции на окружение.
Библиотека предлагает работать с существующими классами Expression, которые и содержат необходимые данные, а именно всю информацию об дочерних и родительских узлах.
Имея набор аргумент необходимо было понять какие выражения соответствуют выражениям присваивания для аргументов функции.
Для этого библиотека также предусматривает все необходимое.

Используя класс MethodDeclaration в библиотеке JavaParser, мы можем анализировать абстрактное синтаксическое дерево.
Для его получения необходимо получить тело функции с помощью метода getBody().

Далее необходимо было проанализировать каждое выражение в теле метода.
Для этого мы использовали класс Expression, описанный выше.

Ниже, в листинге~\ref{listings:ImpactFromEnvironmentExample}, приведен фрагмент кода, в котором анализируются выражения тела метода на наличие оператора присваивания для полей аргументов функции:
\lstinputlisting[
label={listings:ImpactFromEnvironmentExample},
caption={Анализ выражений в теле функции},
style=java,
]
{src/fragments/ImpactFromEnvironmentExample.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация генерации спецификации}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Последней частью реализации, как уже было сказано ранее, была задача создания метода непосредственной генерации кода на языке LibSL.
На данный момент код записывается в выходной файл с расширением .lsl.

Например, ниже, в листинге~\ref{listings:OutputTypeAliasInFile}, приведен фрагмент кода, с помощью которого в файл записывается информация о описании псевдонимов типов:
\lstinputlisting[
label={listings:OutputTypeAliasInFile},
caption={Вывод информации о описании псевдонимов типов в файл},
style=java,
]
{src/fragments/OutputTypeAliasInFile.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были рассмотрены детали реализации прототипа инструмента автоматизированной генерации формальной спецификации библиотеки на языке LibSL.